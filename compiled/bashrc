#compiled on Thu Jul  3 15:22:39 CDT 2014

#shell/blank.bash

#shell/prompt.bash
# @gf3’s Sexy Bash Prompt, inspired by “Extravagant Zsh Prompt”
# Shamelessly copied from https://github.com/gf3/dotfiles
# Screenshot: http://i.imgur.com/s0Blh.png

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
	tput sgr0
	if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
		MAGENTA=$(tput setaf 9)
		ORANGE=$(tput setaf 172)
		GREEN=$(tput setaf 190)
		PURPLE=$(tput setaf 141)
		WHITE=$(tput setaf 0)
	else
		MAGENTA=$(tput setaf 5)
		ORANGE=$(tput setaf 4)
		GREEN=$(tput setaf 2)
		PURPLE=$(tput setaf 1)
		WHITE=$(tput setaf 7)
	fi
	BOLD=$(tput bold)
	RESET=$(tput sgr0)
else
	MAGENTA="\033[1;31m"
	ORANGE="\033[1;33m"
	GREEN="\033[1;32m"
	PURPLE="\033[1;35m"
	WHITE="\033[1;37m"
	BOLD=""
	RESET="\033[m"
fi

export MAGENTA
export ORANGE
export GREEN
export PURPLE
export WHITE
export BOLD
export RESET

function parse_git_dirty() {
	[[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]] && echo "*"
}

function parse_git_branch() {
	git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
}

export PS1="\[${BOLD}${MAGENTA}\]\u \[$WHITE\]at \[$ORANGE\]\h \[$WHITE\]in \[$GREEN\]\w\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[$PURPLE\]\$(parse_git_branch)\[$WHITE\]\n\$ \[$RESET\]"
export PS2="\[$ORANGE\]→ \[$RESET\]"

#shell/alias.sh
# Pipe my public key to my clipboard.
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | echo '=> Public key copied to pasteboard.'"

#serve from local directory
alias serve="python -m SimpleHTTPServer"

alias ack="ack --color"
#shell/env.sh
# Only set this if we haven't set $EDITOR up somewhere else previously.
if [[ "$EDITOR" == "" ]] ; then
  # Use sublime for my editor.
  export EDITOR='vim'
fi

# No permissions, don't bother stealing.
export HOMEBREW_GITHUB_API_TOKEN=ca5f5b692f0bc0dad5e8e16e2e271c654204868b 

export GDAL_DRIVER_PATH=/usr/local/lib/gdalplugins

export DISABLE_KEYERROR=1

#shell/functions.sh

# gem install terminal-notifier
# more info at https://github.com/alloy/terminal-notifier
notify(){
	if [ -z $1 ]; then
		MESSAGE="Done with Task"
	else
		MESSAGE="$@"
	fi
	terminal-notifier -message "$MESSAGE" -sound default
}

shuffle() { 
    awk 'BEGIN{srand();} {printf "%06d %s\n", rand()*1000000, $0;}' | sort -n | cut -c8-
}

#shell/path.sh
export GOPATH=$HOME/go

PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH" #coreutils w/o g prefix
PATH="/usr/local/opt/ruby/bin:$PATH" #gem-installed executables
PATH="/usr/local/Cellar/go/1.2.1/libexec/bin:$PATH" # GOROOT-based install
PATH="$GOPATH/bin:$PATH"
PATH="/Applications/Postgres.app/Contents/Versions/9.3/bin:$PATH" #Postgres.app path
PATH="$HOME/bin:$PATH"
PATH="/usr/local/bin:$PATH" #homebrew path
export PATH

MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"
export MANPATH

PYTHONPATH=/usr/local/lib/python2.7/site-packages:$PYTHONPATH
PYTHONPATH=/usr/local/lib/python:$PYTHONPATH
export PYTHONPATH




#shell/to.sh
# to
# Bookmark locations in bash
#
# Copyright (C) 2013 Mara Kim
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see http://www.gnu.org/licenses/.


TO_BOOKMARK_FILE=~/dotfile/bookmarks
TO_ECHO=\echo
TO_CD=\cd
TO_CAT=\cat
TO_PWD=\pwd
TO_BASENAME=\basename
TO_SED=\sed

function to {
    if [ "$1" ]
    then
if [ "$1" = "-b" ]
        then
local path="$("$TO_PWD")"
            local name
            if [ "$2" ]
            then
if [ $("$TO_SED" -rn "s/(.*\/.*)/\1/p" <<< "$2") ]
                then
                    "$TO_ECHO" "bookmark name may not contain forward slashes" >&2
                    return 1
                fi
name="$2"
            else
name="$("$TO_BASENAME" "$path")"
            fi
            # add bookmark
            _to_rm "$name"
            "$TO_ECHO" "$name|$path" >> "$TO_BOOKMARK_FILE"
        elif [ "$1" = "-r" ]
        then
            # remove bookmark
            _to_rm "$2"
        elif [ -e "$TO_BOOKMARK_FILE" ]
        then
            # go to bookmark if found
            local bookmark="$(_to_path_head "$1")"
            local extra="$(_to_path_tail "$1")"
            local todir="$(_to_dir "$bookmark")"
            if [ "$todir" ]
            then
                "$TO_CD" "$(_to_reldir "$1")"
            else
                "$TO_ECHO" "No shortcut: $bookmark"
            fi
else
            "$TO_ECHO" "No shortcut: $bookmark"
        fi
elif [ -e "$TO_BOOKMARK_FILE" ]
    then
        # show bookmarks
        "$TO_CAT" "$TO_BOOKMARK_FILE"
    fi
}

# get the directory referred to by a bookmark
function _to_dir {
    "$TO_SED" -rn "s/^$1\|(.*)/\1/p" "$TO_BOOKMARK_FILE"
}

# get the first part of the path
function _to_path_head {
    "$TO_SED" -rn "s/^([^/]*)(\/.*)?$/\1/p" <<<"$1"
}

# get the rest of the path
function _to_path_tail {
    "$TO_SED" -rn "s/^[^/]*(\/.*)$/\1/p" <<<"$1"
}

# get the expanded path of a bookmark/path
function _to_reldir {
    local todir="$(_to_dir "$(_to_path_head "$1")" )"
    if [ "$todir" = "/" ]
    then
        # special case for root dir
        "$TO_ECHO" "$(_to_path_tail "$1")"
    else
        "$TO_ECHO" "$todir$(_to_path_tail "$1")"
    fi
}

# remove bookmark
function _to_rm {
    if [ -e "$TO_BOOKMARK_FILE" ]
    then
        "$TO_SED" -ri "/^$1\|.*/ d" "$TO_BOOKMARK_FILE"
    fi
}

# clean input for sed search
function _to_regex {
    if [ "$1" = "/" ]
    then
        # special case for root dir
        "$TO_ECHO"
    else
        "$TO_ECHO" $1 | "$TO_SED" -e 's/[\/&]/\\&/g'
    fi
}

# tab completion bash
function _to {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    local bookmark="$(_to_path_head "$cur")"
    local todir="$( _to_dir "$bookmark")"
    if [ "$prev" = "-b" -o "$prev" = "-r" ]
    then
if [ "$prev" = "-b" ]
        then
            # add current directory
            COMPREPLY="$("$TO_BASENAME" "$($TO_PWD)" )"
        fi
if [ -e "$TO_BOOKMARK_FILE" ]
        then
            # get bookmarks
            COMPREPLY="$("$TO_SED" -rn "s/(.*)\|.*/\1/p" "$TO_BOOKMARK_FILE") $COMPREPLY"

        fi
elif [ -e "$TO_BOOKMARK_FILE" ]
    then
if [ "$todir" ]
        then
            # add subdirectories
            COMPREPLY="$(compgen -S "/" -d "$(_to_reldir $cur)" | $TO_SED -r "s/^$(_to_regex "$todir")/$bookmark/")"
        else
            # get bookmarks (with slash)
            COMPREPLY="$("$TO_SED" -rn "s/(.*)\|.*/\1\//p" "$TO_BOOKMARK_FILE") $COMPREPLY"
        fi
fi
    # generate reply
    COMPREPLY=( $(compgen -W "$COMPREPLY" -- "$cur") )
}

# tab completion zsh
function _to_zsh {
    if [ -e "$TO_BOOKMARK_FILE" ]
    then
reply=(`"$TO_SED" -rn "s/(.*)\|.*/\1/p" "$TO_BOOKMARK_FILE"`)
    fi
}

if [ "$ZSH_VERSION" ]; then
compctl -K _to_zsh to
else
complete -o filenames -o nospace -F _to to
fi
