#compiled on Thu Jul  3 15:32:08 CDT 2014

#shell/oh_my_zsh.zsh
# Path to your oh-my-zsh configuration.
ZSH=$HOME/.oh-my-zsh

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
ZSH_THEME="robbyrussell"

# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# Set to this to use case-sensitive completion
# CASE_SENSITIVE="true"

# Uncomment this to disable bi-weekly auto-update checks
# DISABLE_AUTO_UPDATE="true"

# Uncomment to change how often before auto-updates occur? (in days)
# export UPDATE_ZSH_DAYS=13

# Uncomment following line if you want to disable colors in ls
# DISABLE_LS_COLORS="true"

# Uncomment following line if you want to disable autosetting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment following line if you want to disable command autocorrection
# DISABLE_CORRECTION="true"

# Uncomment following line if you want red dots to be displayed while waiting for completion
# COMPLETION_WAITING_DOTS="true"

# Uncomment following line if you want to disable marking untracked files under
# VCS as dirty. This makes repository status check for large repositories much,
# much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment following line if you want to  shown in the command execution time stamp 
# in the history command output. The optional three formats: "mm/dd/yyyy"|"dd.mm.yyyy"|
# yyyy-mm-dd
# HIST_STAMPS="mm/dd/yyyy"

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(git)

source $ZSH/oh-my-zsh.sh

# User configuration
# export MANPATH="/usr/local/man:$MANPATH"

# # Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# ssh
# export SSH_KEY_PATH="~/.ssh/dsa_id"


#shell/options.zsh
# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=10000
SAVEHIST=10000
bindkey -e
# End of lines configured by zsh-newuser-install
# The following lines were added by compinstall
zstyle :compinstall filename '/Users/SchiBr01/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

#shell/zshhelp.zsh
# Homebrew recommends to put this in the zshrc.
# And I trust homebrew.
unalias run-help
autoload run-help
HELPDIR=/usr/local/share/zsh/helpfiles


#shell/alias.sh
# Pipe my public key to my clipboard.
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | echo '=> Public key copied to pasteboard.'"

#serve from local directory
alias serve="python -m SimpleHTTPServer"

alias ack="ack --color"
#shell/env.sh
# Only set this if we haven't set $EDITOR up somewhere else previously.
if [[ "$EDITOR" == "" ]] ; then
  # Use sublime for my editor.
  export EDITOR='vim'
fi

# No permissions, don't bother stealing.
export HOMEBREW_GITHUB_API_TOKEN=ca5f5b692f0bc0dad5e8e16e2e271c654204868b 

export GDAL_DRIVER_PATH=/usr/local/lib/gdalplugins

export DISABLE_KEYERROR=1

#shell/functions.sh

# gem install terminal-notifier
# more info at https://github.com/alloy/terminal-notifier
notify(){
	if [ -z $1 ]; then
		MESSAGE="Done with Task"
	else
		MESSAGE="$@"
	fi
	terminal-notifier -message "$MESSAGE" -sound default
}

shuffle() { 
    awk 'BEGIN{srand();} {printf "%06d %s\n", rand()*1000000, $0;}' | sort -n | cut -c8-
}

#shell/path.sh
export GOPATH=$HOME/go

PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH" #coreutils w/o g prefix
PATH="/usr/local/opt/ruby/bin:$PATH" #gem-installed executables
PATH="/usr/local/Cellar/go/1.2.1/libexec/bin:$PATH" # GOROOT-based install
PATH="$GOPATH/bin:$PATH"
PATH="/Applications/Postgres.app/Contents/Versions/9.3/bin:$PATH" #Postgres.app path
PATH="$HOME/bin:$PATH"
PATH="/usr/local/bin:$PATH" #homebrew path
export PATH

MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"
export MANPATH

PYTHONPATH=/usr/local/lib/python2.7/site-packages:$PYTHONPATH
PYTHONPATH=/usr/local/lib/python:$PYTHONPATH
export PYTHONPATH




#shell/to.sh
# to
# Bookmark locations in bash
#
# Copyright (C) 2013 Mara Kim
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see http://www.gnu.org/licenses/.


TO_BOOKMARK_FILE=~/dotfile/bookmarks
TO_ECHO=\echo
TO_CD=\cd
TO_CAT=\cat
TO_PWD=\pwd
TO_BASENAME=\basename
TO_SED=\sed

function to {
    if [ "$1" ]
    then
if [ "$1" = "-b" ]
        then
local path="$("$TO_PWD")"
            local name
            if [ "$2" ]
            then
if [ $("$TO_SED" -En "s/(.*\/.*)/\1/p" <<< "$2") ]
                then
                    "$TO_ECHO" "bookmark name may not contain forward slashes" >&2
                    return 1
                fi
name="$2"
            else
name="$("$TO_BASENAME" "$path")"
            fi
            # add bookmark
            _to_rm "$name"
            "$TO_ECHO" "$name|$path" >> "$TO_BOOKMARK_FILE"
        elif [ "$1" = "-r" ]
        then
            # remove bookmark
            _to_rm "$2"
        elif [ -e "$TO_BOOKMARK_FILE" ]
        then
            # go to bookmark if found
            local bookmark="$(_to_path_head "$1")"
            local extra="$(_to_path_tail "$1")"
            local todir="$(_to_dir "$bookmark")"
            if [ "$todir" ]
            then
                "$TO_CD" "$(_to_reldir "$1")"
            else
                "$TO_ECHO" "No shortcut: $bookmark"
            fi
else
            "$TO_ECHO" "No shortcut: $bookmark"
        fi
elif [ -e "$TO_BOOKMARK_FILE" ]
    then
        # show bookmarks
        "$TO_CAT" "$TO_BOOKMARK_FILE"
    fi
}

# get the directory referred to by a bookmark
function _to_dir {
    "$TO_SED" -En "s/^$1\|(.*)/\1/p" "$TO_BOOKMARK_FILE"
}

# get the first part of the path
function _to_path_head {
    "$TO_SED" -En "s/^([^/]*)(\/.*)?$/\1/p" <<<"$1"
}

# get the rest of the path
function _to_path_tail {
    "$TO_SED" -En "s/^[^/]*(\/.*)$/\1/p" <<<"$1"
}

# get the expanded path of a bookmark/path
function _to_reldir {
    local todir="$(_to_dir "$(_to_path_head "$1")" )"
    if [ "$todir" = "/" ]
    then
        # special case for root dir
        "$TO_ECHO" "$(_to_path_tail "$1")"
    else
        "$TO_ECHO" "$todir$(_to_path_tail "$1")"
    fi
}

# remove bookmark
function _to_rm {
    if [ -e "$TO_BOOKMARK_FILE" ]
    then
        "$TO_SED" -Ei "/^$1\|.*/ d" "$TO_BOOKMARK_FILE"
    fi
}

# clean input for sed search
function _to_regex {
    if [ "$1" = "/" ]
    then
        # special case for root dir
        "$TO_ECHO"
    else
        "$TO_ECHO" $1 | "$TO_SED" -e 's/[\/&]/\\&/g'
    fi
}

# tab completion bash
function _to {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    local bookmark="$(_to_path_head "$cur")"
    local todir="$( _to_dir "$bookmark")"
    if [ "$prev" = "-b" -o "$prev" = "-r" ]
    then
if [ "$prev" = "-b" ]
        then
            # add current directory
            COMPREPLY="$("$TO_BASENAME" "$($TO_PWD)" )"
        fi
if [ -e "$TO_BOOKMARK_FILE" ]
        then
            # get bookmarks
            COMPREPLY="$("$TO_SED" -En "s/(.*)\|.*/\1/p" "$TO_BOOKMARK_FILE") $COMPREPLY"

        fi
elif [ -e "$TO_BOOKMARK_FILE" ]
    then
if [ "$todir" ]
        then
            # add subdirectories
            COMPREPLY="$(compgen -S "/" -d "$(_to_reldir $cur)" | $TO_SED -E "s/^$(_to_regex "$todir")/$bookmark/")"
        else
            # get bookmarks (with slash)
            COMPREPLY="$("$TO_SED" -En "s/(.*)\|.*/\1\//p" "$TO_BOOKMARK_FILE") $COMPREPLY"
        fi
fi
    # generate reply
    COMPREPLY=( $(compgen -W "$COMPREPLY" -- "$cur") )
}

# tab completion zsh
function _to_zsh {
    if [ -e "$TO_BOOKMARK_FILE" ]
    then
reply=(`"$TO_SED" -En "s/(.*)\|.*/\1/p" "$TO_BOOKMARK_FILE"`)
    fi
}

if [ "$ZSH_VERSION" ]; then
compctl -K _to_zsh to
else
complete -o filenames -o nospace -F _to to
fi
